--
-- DO NOT EDIT THIS FILE UNLESS YOU KNOW WHAT YOU ARE DOING
--
-- Program: BloodAltarLUA
--
-- Description: Automatize Blood Magic's Altar with ComputerCraft/CC:Tweaked.
--
-- Author: Scheigy
--
-- Source: https://github.com/iammael/BloodAltarLUA
--
--
local LIP = require 'LIP'
local CONFIG = LIP.load("config.ini")

local mon = peripheral.find("monitor")
local inputChest = peripheral.wrap("minecraft:chest_0")
local outputChest = peripheral.wrap("minecraft:chest_1")
local altar = peripheral.wrap("entangled:tile_1")

--
local RECIPES = {}

--
local CURRENT_LOG_ON_MONITOR = 0
local TOTAL_CRAFTS_SESSION = 0

-- DYNAMIC RECIPES

function createRecipes()
    local recipesData = LIP.load("recipes.ini")
    local i = 0

    for index, recipe in pairs(recipesData) do
        i = i + 1
        -- print(index, recipe.name)
        RECIPES[i] = {
            ingredient = recipe.ingredient,
            -- displayName = recipe.displayName,
            cost = recipe.cost
        }
    end
end

-- END DYNAMIC RECIPES

-- CONFIG

function updateConfig()
    CONFIG.Program.TOTAL_CRAFTS = CONFIG.Program.TOTAL_CRAFTS + TOTAL_CRAFTS_SESSION
    LIP.save("config.ini", CONFIG)
end

-- MONITOR

function logOnMonitor(msg, type)
    print("[MON] " .. msg)

    -- Erase log if screen too full
    if (CURRENT_LOG_ON_MONITOR == CONFIG.Program.MAX_LOG_ON_MONITOR) then
        initMonitor()
        CURRENT_LOG_ON_MONITOR = 0
    end

    -- Change color base on message type
    if (type == "warning") then
        mon.setTextColor(colors.orange)
    elseif (type == "error") then
        mon.setTextColor(colors.red)
    elseif (type == "success") then
        mon.setTextColor(colors.green)
    else
        mon.setTextColor(colors.white)
    end

    local cursorPosY = 5 + CURRENT_LOG_ON_MONITOR
    mon.setCursorPos(2, cursorPosY)
    local textToWrite = os.date("[%X] ") .. msg
    mon.write(textToWrite)
    CURRENT_LOG_ON_MONITOR = CURRENT_LOG_ON_MONITOR + 1
end

-- Footer
function writeFooterOnMonitor()
    mon.setTextColor(colors.white)
    mon.setCursorPos(40, 18)
    mon.write("Total:")
    mon.setCursorPos(40, 19)
    mon.write(CONFIG.Program.TOTAL_CRAFTS .. " crafts")
end

function initMonitor()
    mon.setBackgroundColor(colors.black)
    mon.clear()
    mon.setTextColor(colors.white)
    mon.setTextScale(1.3)

    -- Title
    mon.setCursorPos(18, 1)
    mon.setTextColor(colors.red)
    mon.write("BloodAltar")
    mon.setTextColor(colors.green)
    mon.write("LUA")

    -- Log Header
    mon.setTextColor(colors.white)
    mon.setCursorPos(2, 3)
    mon.write("Log:")

    writeFooterOnMonitor()
end

-- CRAFT

function tryCrafting()
    local listInputChest = inputChest.list()
    local nbCrafts = 0

    if (#listInputChest == 0) then
        return -1
    else
        for x = 1, #listInputChest do
            local craftTable = {
                name = listInputChest[x].name,
                count = listInputChest[x].count,
                slot = x
            }

            for y = 1, craftTable.count do
                while (checkTankCapacityRequirements(craftTable) == false) do
                    sleep(5)
                end
                if (craft(craftTable) == -1) then
                    return -2
                else
                    nbCrafts = nbCrafts + 1
                end

            end
        end
    end

    TOTAL_CRAFTS_SESSION = TOTAL_CRAFTS_SESSION + nbCrafts
    return nbCrafts
end

function craft(craftTable)
    -- Printing current craft on monitor
    for x = 1, #RECIPES do
        if (string.find(RECIPES[x].ingredient, craftTable.name) ~= nil) then
            logOnMonitor("Infusing 1 " .. craftTable.name .. "...")
        end
    end

    inputChest.pushItems(peripheral.getName(altar), craftTable.slot, 1)
    if (waitForInfusion(craftTable.name) == false) then
        return -1
    else
        outputChest.pullItems(peripheral.getName(altar), 1)
    end
    return 0
end

function waitForInfusion(itemInAltar)
    local i = 0

    while i < CONFIG.Program.TIMEOUT do
        local slateInAltar = altar.list()[1]
        if (slateInAltar.name == itemInAltar) then
            sleep(0.5)
            i = i + 1
        else
            return 0
        end
    end
    return -1
end

function checkTankCapacityRequirements(craftTable)
    if altar.tanks() == {} then
        return false -- Tank Empty
    end

    local currentLifeEssence = altar.tanks()[1].amount

    if (currentLifeEssence >= CONFIG.Altar.LIFE_ESSENCE_REQUIRED_MIN) then
        return true
    end

    for x = 1, #RECIPES do
        if (RECIPES[x].ingredient == craftTable.name) then
            if (currentLifeEssence >= RECIPES[x].cost) then
                return true
            else
                logOnMonitor("Tank capacity is < " .. RECIPES[x].cost .. ".", "warning")
                return false
            end
        end
    end

    logOnMonitor("Tank capacity is < " .. CONFIG.Altar.LIFE_ESSENCE_REQUIRED_MIN .. ".", "warning")
    return false
end

-- MISC FUNC

function printDebug(msg)
    if CONFIG.Program.DEBUG == true then
        print(msg)
    end
end

--

function init()
    term.clear()

    createRecipes()
    initMonitor()

    logOnMonitor("Program initiated successfully.", "success")
    logOnMonitor("Dynamically loaded " .. #RECIPES .. " recipes!", "success")
    logOnMonitor("github.com/iammael/BloodAltarLUA", "success")
end

function main()
    init()

    while true do
        ret = tryCrafting()

        if ret == -1 then -- Nothing is found in the input chest
            if (CONFIG.Program.DEBUG == true) then
                logOnMonitor("Nothing to do.")
            end
            sleep(CONFIG.Program.WAIT_TIME)
        elseif ret == -2 then -- The crafting happened for too long
            logOnMonitor("Crafting was stuck for (" .. CONFIG.Program.TIMEOUT .. " seconds).", "error")
            sleep(CONFIG.Program.WAIT_TIME)
        else
            updateConfig()
            logOnMonitor("Successfully crafted " .. ret .. " item(s).", "success")
            writeFooterOnMonitor()
            TOTAL_CRAFTS_SESSION = 0
            sleep(1)
        end
    end
end

main()
